#! /usr/bin/env python

# No Copyright (-) 2010 The Ampify Authors. This file is under the
# Public Domain license that can be found in the root LICENSE file.

"""A git-command to support git reviews."""

import pylibs
import sys

from optparse import OptionParser
from os.path import join
from urllib import urlencode, urlopen

from optcomplete import autocomplete, ListCompleter
from optcomplete import make_autocompleter, parse_options
from pyutil.env import exit, run_command
from pyutil.scm import is_git, SCMConfig
from yaml import safe_load as decode_yaml

# ------------------------------------------------------------------------------
# Settings
# ------------------------------------------------------------------------------

CONFIG = {}

# ------------------------------------------------------------------------------
# Utility Functions
# ------------------------------------------------------------------------------

def git(*args, **kwargs):
    if 'exit_on_error' not in kwargs:
        kwargs['exit_on_error'] = True
    if kwargs.pop('out', None):
        kwargs['redirect_stdout'] = False
        kwargs['redirect_stderr'] = False
        kwargs['retcode'] = True
    return run_command(['git'] + list(args), **kwargs)

def setup_remote(name, config_value=None):
    if not git('config', 'remote.%s.url' % name, exit_on_error=False):
        if not config_value:
            config_value = '%s_repo' % name
        url = CONFIG[config_value]
        print "=> Setting the %r remote: %s" % (name, url)
        git('remote', 'add', name, url)

def parse_config(root):
    config_path = join(root, '.gitreview', 'config.yaml')
    config_file = open(config_path)
    config_data = config_file.read()
    config_file.close()
    config = decode_yaml(config_data)
    if config:
        CONFIG.update(config)

def valid_review_id(id, valid=set('abcdefghijklmnopqrstuvwxyz0123456789-_')):
    id = id.lower()
    if id.startswith('-') or id.startswith('_'):
        return
    for char in id:
        if char not in valid:
            return
    return id

def get_git_info():

    git = SCMConfig('git')
    login = git.get('github.user')
    token = git.get('github.token')

    if not login:
        print "ERROR: You need to set your GitHub username, e.g."
        print
        print "    git config --global github.user tav"
        print

    if not token:
        print "ERROR: You need to set your GitHub API token, e.g."
        print
        print "    git config --global github.token 86f7e437faa5a7fce15d1ddcb9eaeae4"
        print
        print "You can find your API Token in the Account Admin section at:"
        print
        print "    https://github.com/account"
        print

    if not (login and token):
        sys.exit(1)

    return login, token, git.root

# ------------------------------------------------------------------------------
# Main Runner
# ------------------------------------------------------------------------------

def main(argv=None, show_help=False):

    argv = argv or sys.argv[1:]

    sys.argv[0] = 'git review'
    version = '0.1'

    usage = ("""Usage: git review <command> [options]
    \nCommands:
    \n%s
    version  show the version number and exit
    \nIf no commands are given, `git review check` is run.
    \nSee `git review help <command>` for more info on a specific command.""" %
    '\n'.join("    %-8s %s" % (cmd, COMMANDS[cmd].help) for cmd in sorted(COMMANDS))
    )

    autocomplete(
        OptionParser(add_help_option=False),
        ListCompleter(AUTOCOMPLETE_COMMANDS.keys()),
        subcommands=AUTOCOMPLETE_COMMANDS
        )

    if not argv:
        command = 'check'
    else:
        command = argv[0]
        argv = argv[1:]
        if command in ['-h', '--help']:
            show_help = True
        elif command == 'help':
            if argv:
                command = argv[0]
                argv = ['--help']
            else:
                show_help = True
        if command in ['-v', '--version', 'version']:
            print('git-review %s' % version)
            sys.exit()

    if show_help:
        print(usage)
        sys.exit(1)

    if not is_git():
        print "ERROR: Not inside a git repository."
        sys.exit()

    if command in COMMANDS:
        return COMMANDS[command](argv)

    exit("ERROR: Unknown git review command %r" % command)

# ------------------------------------------------------------------------------
# Apply Command
# ------------------------------------------------------------------------------

def apply(argv=None, completer=None):

    op = OptionParser(
        usage="Usage: git review apply <review-id> [options]",
        add_help_option=False
        )

    options, args = parse_options(op, argv, completer, True)

# ------------------------------------------------------------------------------
# Check Command
# ------------------------------------------------------------------------------

def check(argv=None, completer=None):

    op = OptionParser(
        usage="Usage: git review check [options]",
        add_help_option=False
        )

    options, args = parse_options(op, argv, completer, False)

# ------------------------------------------------------------------------------
# Submit Command
# ------------------------------------------------------------------------------

def submit(argv=None, completer=None):

    op = OptionParser(
        usage="Usage: git review submit [options]",
        add_help_option=False
        )

    op.add_option('-m', dest='msg', default="",
                  help="use the message as the title for the review item")

    options, args = parse_options(op, argv, completer, False)
    login, token, root = get_git_info()
    parse_config(root)
    setup_remote('upstream')

    for branch in git('branch').splitlines():
        if branch.startswith('*'):
            current_branch = branch.split('*', 1)[1].strip()
            break
    else:
        print "ERROR: Couldn't detect the current git branch."
        sys.exit(1)

    if current_branch == 'master':
        print "ERROR: You can't submit a master branch for review."
        sys.exit(1)

    HEAD = git('rev-parse', 'HEAD').strip()

    sys.stdout.write("=> ")
    sys.stdout.flush()
    git('remote', 'update', 'upstream', out=True)

    upstream_master = 'upstream/%s' % CONFIG['upstream_branch']
    upstream_revision = git('rev-parse', upstream_master).strip()

    base_revision = git('merge-base', HEAD, upstream_revision).strip()
    if base_revision == HEAD:
        print "ERROR: All the changes have already been merged upstream."
        sys.exit()

    for branch in git('branch', '--contains', upstream_revision):
        if branch.startswith('*'):
            rebase = False
            break
    else:
        rebase = True

    if rebase:
        print
        print "The upstream/master has changed. You need to rebase."
        print
        response = raw_input("Hit enter to run `git rebase -i` [Y/n] ")
        if response.startswith('n'):
            sys.exit(1)
        print
        git('rebase', '-i', upstream_revision, out=True)
        print
        HEAD = git('rev-parse', 'HEAD').strip()

    print "=> Generating patch"
    patch = git('format-patch', upstream_revision, '--stdout')

    if not patch.strip():
        print "ERROR: Generated patch is empty. Nothing to send!"
        sys.exit(1)

    print "=> Sending patch to the review-server"
    review_server = CONFIG['review_server']
    server = urlopen(review_server + '/review', urlencode({
        'id': current_branch,
        'revision': HEAD,
        'patch': patch,
        'login': login,
        'token': token,
        'message': options.msg,
        'upstream': upstream_revision
        }))

    path = server.read()
    server.close()

    if path.startswith('OK '):
        path = path.split('OK ', 1)[1].strip()
        print "=> You can see the review at:"
        print
        print "        %s/review/%s" % (review_server, path)
        print
    else:
        print "ERROR: %s" % path
        sys.exit(1)

# ------------------------------------------------------------------------------
# Update Command
# ------------------------------------------------------------------------------

def update(argv=None, completer=None):

    op = OptionParser(usage="Usage: git review update", add_help_option=False)
    parse_options(op, argv, completer, False)
    parse_config(SCMConfig('git').root)

    for remote, cfg in [
        ('upstream', 'upstream_repo'), ('gitreview', 'review_repo')
        ]:
        setup_remote(remote, cfg)
        sys.stdout.write("=> ")
        sys.stdout.flush()
        git('remote', 'update', remote, out=True)

# ------------------------------------------------------------------------------
# Help Strings
# ------------------------------------------------------------------------------

# These, along with other strings, should perhaps be internationalised at a
# later date.
apply.help = "fetch and apply a review changeset"
check.help = "run the automated review checks for this repository"
submit.help = "submit the current branch for review"
update.help = "add the upstream/gitserver remotes and update them"

# ------------------------------------------------------------------------------
# Command Mapping
# ------------------------------------------------------------------------------

COMMANDS = {
    'apply': apply,
    'check': check,
    'submit': submit,
    'update': update
    }

# ------------------------------------------------------------------------------
# Command Autocompletion
# ------------------------------------------------------------------------------

AUTOCOMPLETE_COMMANDS = COMMANDS.copy()

AUTOCOMPLETE_COMMANDS['help'] = lambda completer: (
    OptionParser(add_help_option=False),
    ListCompleter(COMMANDS.keys())
    )

AUTOCOMPLETE_COMMANDS['version'] = lambda completer: (
    OptionParser(add_help_option=False),
    DirCompleter(AMPIFY_ROOT_PARENT)
    )

for command in AUTOCOMPLETE_COMMANDS.values():
    command.autocomplete = make_autocompleter(command)

# ------------------------------------------------------------------------------
# Self Runner
# ------------------------------------------------------------------------------

if __name__ == '__main__':
    main()
